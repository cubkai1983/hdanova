#' Hypothesis test for high-dimensional data
#' @description Test the mean or differences of means of high-dimensional vectors are zero or not
#' @param X a matrix (one sample) or a list of matrices (two samples or more), with observations contained in rows
#' @param alpha significance level
#' @param tau the decay parameter, automatically selected if set to \code{NULL}
#' @param B the number of bootstrap replicates
#' @param pairs a matrix with two columns, used when there are more than two populations, each row specifying a pair of populations whose means are compared, and if set to \code{NULL}, comparisons for all pairs are performed
#' @param Sig a matrix (one sample) or a list of matrices, each of them is the covariance matrix of a sample and automatically estimated if \code{NULL}
#' @return a list of objects: \code{reject} is a boolean variable indicating whether the null is rejected or not. If the null if reject, \code{rej.pairs} optionally gives the pairs of samples that lead to rejection. \code{pvalue} is also returned.
#' @importFrom Rdpack reprompt
#' @references 
#' \insertRef{Lopes2019+}{hdanova}
#' 
#' \insertRef{Lin2020}{hdanova}
#' @examples
#' # simulate a dataset of 4 samples
#' X <- lapply(1:4, function(g) MASS::mvrnorm(30,rep(0,10),diag((1:10)^(-0.5*g))))
#' 
#' # test for the equality of mean vectors with pairs={(1,3),(2,4)}
#' hdtest(X,alpha=0.05,pairs=matrix(1:4,2,2))$reject
#' @export
hdtest <- function(X,alpha=0.05,tau=NULL,B=1000,pairs=NULL,Sig=NULL,verbose=F)
{
    if(is.list(X)) G <- length(X)
    else if(is.matrix(X)) G <- 1
    else stop('X must be a matrix or a list of matrices')
    
    sci <- hdsci(X,alpha,'both',tau,B,pairs,Sig,verbose)
    
    lo <- sci$sci.lower
    up <- sci$sci.upper
    if(is.list(lo))
    {
        lo <- unlist(lo)
        up <- unlist(up)
    }
    if(any(lo > 0) || any(up < 0)) reject <- TRUE
    else reject <- FALSE
    
    res <- list(reject=reject,accept=!reject,tau=sci$tau)
    
    if(reject && G > 2)
    {
        rej.idx <- sapply(sci$sci.lower,function(z) any(z>0)) |
            sapply(sci$sci.upper, function(z) any(z<0))
        rej.pairs <- sci$pairs[which(rej.idx==1),]
        res$rej.pairs <- rej.pairs
    }
    
    # compute p-value
    
    zl <- Inf
    zu <- -Inf
    pairs <- sci$pairs
    Sig <- sci$Sig
    tau <- sci$tau
    ns <- sapply(X,function(x){nrow(x)})
    
    for(q in 1:nrow(pairs))
    {
        j <- pairs[q,1]
        k <- pairs[q,2]
        
        lamj <- sqrt(ns[k]/(ns[j]+ns[k]))
        lamk <- sqrt(ns[j]/(ns[j]+ns[k]))
        
        sig2j <- diag(Sig[[j]])
        sig2k <- diag(Sig[[k]])
        
        sigma <- sqrt(lamj^2 * sig2j + lamk^2 * sig2k)^tau 
        
        X.bar <- apply(X[[j]],2,mean)
        Y.bar <- apply(X[[k]],2,mean)
        sqrt.harm.n <- sqrt(ns[j]*ns[k]/(ns[j]+ns[k]))
        
        idx <- (sigma!=0)
        
        sigma <- sigma[idx]
        
        tmp <- X.bar-Y.bar
        tmp <- tmp[idx]
        
        zl <- min(zl,min(tmp*sqrt.harm.n/sigma))
        zu <- max(zu,max(tmp*sqrt.harm.n/sigma))
    }
    
    eta <- mean(sci$Mn.sorted >= zu)
    eta <- min(eta,mean(sci$Ln.sorted <= zl))
    
    res$pvalue <- min(1,2*eta)
    
    return(res)
}